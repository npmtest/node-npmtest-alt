{"/home/travis/build/npmtest/node-npmtest-alt/test.js":"/* istanbul instrument in package npmtest_alt */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-alt/lib.npmtest_alt.js":"/* istanbul instrument in package npmtest_alt */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_alt = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_alt = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-alt/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-alt && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_alt */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_alt\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_alt.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_alt.rollup.js'] =\n            local.assetsDict['/assets.npmtest_alt.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_alt.__dirname + '/lib.npmtest_alt.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-alt/node_modules/alt/lib/index.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _flux = require('flux');\n\nvar _StateFunctions = require('./utils/StateFunctions');\n\nvar StateFunctions = _interopRequireWildcard(_StateFunctions);\n\nvar _functions = require('./functions');\n\nvar fn = _interopRequireWildcard(_functions);\n\nvar _store = require('./store');\n\nvar store = _interopRequireWildcard(_store);\n\nvar _AltUtils = require('./utils/AltUtils');\n\nvar utils = _interopRequireWildcard(_AltUtils);\n\nvar _actions = require('./actions');\n\nvar _actions2 = _interopRequireDefault(_actions);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /* global window */\n\n\nvar Alt = function () {\n  function Alt() {\n    var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    _classCallCheck(this, Alt);\n\n    this.config = config;\n    this.serialize = config.serialize || JSON.stringify;\n    this.deserialize = config.deserialize || JSON.parse;\n    this.dispatcher = config.dispatcher || new _flux.Dispatcher();\n    this.batchingFunction = config.batchingFunction || function (callback) {\n      return callback();\n    };\n    this.actions = { global: {} };\n    this.stores = {};\n    this.storeTransforms = config.storeTransforms || [];\n    this.trapAsync = false;\n    this._actionsRegistry = {};\n    this._initSnapshot = {};\n    this._lastSnapshot = {};\n  }\n\n  Alt.prototype.dispatch = function () {\n    function dispatch(action, data, details) {\n      var _this = this;\n\n      this.batchingFunction(function () {\n        var id = Math.random().toString(18).substr(2, 16);\n\n        // support straight dispatching of FSA-style actions\n        if (action.hasOwnProperty('type') && action.hasOwnProperty('payload')) {\n          var fsaDetails = {\n            id: action.type,\n            namespace: action.type,\n            name: action.type\n          };\n          return _this.dispatcher.dispatch(utils.fsa(id, action.type, action.payload, fsaDetails));\n        }\n\n        if (action.id && action.dispatch) {\n          return utils.dispatch(id, action, data, _this);\n        }\n\n        return _this.dispatcher.dispatch(utils.fsa(id, action, data, details));\n      });\n    }\n\n    return dispatch;\n  }();\n\n  Alt.prototype.createUnsavedStore = function () {\n    function createUnsavedStore(StoreModel) {\n      var key = StoreModel.displayName || '';\n      store.createStoreConfig(this.config, StoreModel);\n      var Store = store.transformStore(this.storeTransforms, StoreModel);\n\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return fn.isFunction(Store) ? store.createStoreFromClass.apply(store, [this, Store, key].concat(args)) : store.createStoreFromObject(this, Store, key);\n    }\n\n    return createUnsavedStore;\n  }();\n\n  Alt.prototype.createStore = function () {\n    function createStore(StoreModel, iden) {\n      var key = iden || StoreModel.displayName || StoreModel.name || '';\n      store.createStoreConfig(this.config, StoreModel);\n      var Store = store.transformStore(this.storeTransforms, StoreModel);\n\n      /* istanbul ignore next */\n      if (module.hot) delete this.stores[key];\n\n      if (this.stores[key] || !key) {\n        if (this.stores[key]) {\n          utils.warn('A store named ' + String(key) + ' already exists, double check your store ' + 'names or pass in your own custom identifier for each store');\n        } else {\n          utils.warn('Store name was not specified');\n        }\n\n        key = utils.uid(this.stores, key);\n      }\n\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      var storeInstance = fn.isFunction(Store) ? store.createStoreFromClass.apply(store, [this, Store, key].concat(args)) : store.createStoreFromObject(this, Store, key);\n\n      this.stores[key] = storeInstance;\n      StateFunctions.saveInitialSnapshot(this, key);\n\n      return storeInstance;\n    }\n\n    return createStore;\n  }();\n\n  Alt.prototype.generateActions = function () {\n    function generateActions() {\n      var actions = { name: 'global' };\n\n      for (var _len3 = arguments.length, actionNames = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        actionNames[_key3] = arguments[_key3];\n      }\n\n      return this.createActions(actionNames.reduce(function (obj, action) {\n        obj[action] = utils.dispatchIdentity;\n        return obj;\n      }, actions));\n    }\n\n    return generateActions;\n  }();\n\n  Alt.prototype.createAction = function () {\n    function createAction(name, implementation, obj) {\n      return (0, _actions2['default'])(this, 'global', name, implementation, obj);\n    }\n\n    return createAction;\n  }();\n\n  Alt.prototype.createActions = function () {\n    function createActions(ActionsClass) {\n      var _this3 = this;\n\n      var exportObj = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var actions = {};\n      var key = utils.uid(this._actionsRegistry, ActionsClass.displayName || ActionsClass.name || 'Unknown');\n\n      if (fn.isFunction(ActionsClass)) {\n        fn.assign(actions, utils.getPrototypeChain(ActionsClass));\n\n        var ActionsGenerator = function (_ActionsClass) {\n          _inherits(ActionsGenerator, _ActionsClass);\n\n          function ActionsGenerator() {\n            _classCallCheck(this, ActionsGenerator);\n\n            for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n              args[_key5] = arguments[_key5];\n            }\n\n            return _possibleConstructorReturn(this, _ActionsClass.call.apply(_ActionsClass, [this].concat(args)));\n          }\n\n          ActionsGenerator.prototype.generateActions = function () {\n            function generateActions() {\n              for (var _len6 = arguments.length, actionNames = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n                actionNames[_key6] = arguments[_key6];\n              }\n\n              actionNames.forEach(function (actionName) {\n                actions[actionName] = utils.dispatchIdentity;\n              });\n            }\n\n            return generateActions;\n          }();\n\n          return ActionsGenerator;\n        }(ActionsClass);\n\n        for (var _len4 = arguments.length, argsForConstructor = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n          argsForConstructor[_key4 - 2] = arguments[_key4];\n        }\n\n        fn.assign(actions, new (Function.prototype.bind.apply(ActionsGenerator, [null].concat(argsForConstructor)))());\n      } else {\n        fn.assign(actions, ActionsClass);\n      }\n\n      this.actions[key] = this.actions[key] || {};\n\n      fn.eachObject(function (actionName, action) {\n        if (!fn.isFunction(action)) {\n          exportObj[actionName] = action;\n          return;\n        }\n\n        // create the action\n        exportObj[actionName] = (0, _actions2['default'])(_this3, key, actionName, action, exportObj);\n\n        // generate a constant\n        var constant = utils.formatAsConstant(actionName);\n        exportObj[constant] = exportObj[actionName].id;\n      }, [actions]);\n\n      return exportObj;\n    }\n\n    return createActions;\n  }();\n\n  Alt.prototype.takeSnapshot = function () {\n    function takeSnapshot() {\n      for (var _len7 = arguments.length, storeNames = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        storeNames[_key7] = arguments[_key7];\n      }\n\n      var state = StateFunctions.snapshot(this, storeNames);\n      fn.assign(this._lastSnapshot, state);\n      return this.serialize(state);\n    }\n\n    return takeSnapshot;\n  }();\n\n  Alt.prototype.rollback = function () {\n    function rollback() {\n      StateFunctions.setAppState(this, this.serialize(this._lastSnapshot), function (storeInst) {\n        storeInst.lifecycle('rollback');\n        storeInst.emitChange();\n      });\n    }\n\n    return rollback;\n  }();\n\n  Alt.prototype.recycle = function () {\n    function recycle() {\n      for (var _len8 = arguments.length, storeNames = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        storeNames[_key8] = arguments[_key8];\n      }\n\n      var initialSnapshot = storeNames.length ? StateFunctions.filterSnapshots(this, this._initSnapshot, storeNames) : this._initSnapshot;\n\n      StateFunctions.setAppState(this, this.serialize(initialSnapshot), function (storeInst) {\n        storeInst.lifecycle('init');\n        storeInst.emitChange();\n      });\n    }\n\n    return recycle;\n  }();\n\n  Alt.prototype.flush = function () {\n    function flush() {\n      var state = this.serialize(StateFunctions.snapshot(this));\n      this.recycle();\n      return state;\n    }\n\n    return flush;\n  }();\n\n  Alt.prototype.bootstrap = function () {\n    function bootstrap(data) {\n      StateFunctions.setAppState(this, data, function (storeInst, state) {\n        storeInst.lifecycle('bootstrap', state);\n        storeInst.emitChange();\n      });\n    }\n\n    return bootstrap;\n  }();\n\n  Alt.prototype.prepare = function () {\n    function prepare(storeInst, payload) {\n      var data = {};\n      if (!storeInst.displayName) {\n        throw new ReferenceError('Store provided does not have a name');\n      }\n      data[storeInst.displayName] = payload;\n      return this.serialize(data);\n    }\n\n    return prepare;\n  }();\n\n  // Instance type methods for injecting alt into your application as context\n\n  Alt.prototype.addActions = function () {\n    function addActions(name, ActionsClass) {\n      for (var _len9 = arguments.length, args = Array(_len9 > 2 ? _len9 - 2 : 0), _key9 = 2; _key9 < _len9; _key9++) {\n        args[_key9 - 2] = arguments[_key9];\n      }\n\n      this.actions[name] = Array.isArray(ActionsClass) ? this.generateActions.apply(this, ActionsClass) : this.createActions.apply(this, [ActionsClass].concat(args));\n    }\n\n    return addActions;\n  }();\n\n  Alt.prototype.addStore = function () {\n    function addStore(name, StoreModel) {\n      for (var _len10 = arguments.length, args = Array(_len10 > 2 ? _len10 - 2 : 0), _key10 = 2; _key10 < _len10; _key10++) {\n        args[_key10 - 2] = arguments[_key10];\n      }\n\n      this.createStore.apply(this, [StoreModel, name].concat(args));\n    }\n\n    return addStore;\n  }();\n\n  Alt.prototype.getActions = function () {\n    function getActions(name) {\n      return this.actions[name];\n    }\n\n    return getActions;\n  }();\n\n  Alt.prototype.getStore = function () {\n    function getStore(name) {\n      return this.stores[name];\n    }\n\n    return getStore;\n  }();\n\n  Alt.debug = function () {\n    function debug(name, alt, win) {\n      var key = 'alt.js.org';\n      var context = win;\n      if (!context && typeof window !== 'undefined') {\n        context = window;\n      }\n      if (typeof context !== 'undefined') {\n        context[key] = context[key] || [];\n        context[key].push({ name: name, alt: alt });\n      }\n      return alt;\n    }\n\n    return debug;\n  }();\n\n  return Alt;\n}();\n\nexports['default'] = Alt;\nmodule.exports = exports['default'];","/home/travis/build/npmtest/node-npmtest-alt/node_modules/alt/lib/utils/StateFunctions.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setAppState = setAppState;\nexports.snapshot = snapshot;\nexports.saveInitialSnapshot = saveInitialSnapshot;\nexports.filterSnapshots = filterSnapshots;\n\nvar _functions = require('../functions');\n\nvar fn = _interopRequireWildcard(_functions);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction setAppState(instance, data, onStore) {\n  var obj = instance.deserialize(data);\n  fn.eachObject(function (key, value) {\n    var store = instance.stores[key];\n    if (store) {\n      (function () {\n        var config = store.StoreModel.config;\n\n        var state = store.state;\n        if (config.onDeserialize) obj[key] = config.onDeserialize(value) || value;\n        if (fn.isMutableObject(state)) {\n          fn.eachObject(function (k) {\n            return delete state[k];\n          }, [state]);\n          fn.assign(state, obj[key]);\n        } else {\n          store.state = obj[key];\n        }\n        onStore(store, store.state);\n      })();\n    }\n  }, [obj]);\n}\n\nfunction snapshot(instance) {\n  var storeNames = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n  var stores = storeNames.length ? storeNames : Object.keys(instance.stores);\n  return stores.reduce(function (obj, storeHandle) {\n    var storeName = storeHandle.displayName || storeHandle;\n    var store = instance.stores[storeName];\n    var config = store.StoreModel.config;\n\n    store.lifecycle('snapshot');\n    var customSnapshot = config.onSerialize && config.onSerialize(store.state);\n    obj[storeName] = customSnapshot ? customSnapshot : store.getState();\n    return obj;\n  }, {});\n}\n\nfunction saveInitialSnapshot(instance, key) {\n  var state = instance.deserialize(instance.serialize(instance.stores[key].state));\n  instance._initSnapshot[key] = state;\n  instance._lastSnapshot[key] = state;\n}\n\nfunction filterSnapshots(instance, state, stores) {\n  return stores.reduce(function (obj, store) {\n    var storeName = store.displayName || store;\n    if (!state[storeName]) {\n      throw new ReferenceError(String(storeName) + ' is not a valid store');\n    }\n    obj[storeName] = state[storeName];\n    return obj;\n  }, {});\n}","/home/travis/build/npmtest/node-npmtest-alt/node_modules/alt/lib/functions.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isMutableObject = isMutableObject;\nexports.eachObject = eachObject;\nexports.assign = assign;\nvar isFunction = exports.isFunction = function isFunction(x) {\n  return typeof x === 'function';\n};\n\nfunction isMutableObject(target) {\n  var Ctor = target.constructor;\n\n  return !!target && Object.prototype.toString.call(target) === '[object Object]' && isFunction(Ctor) && !Object.isFrozen(target) && (Ctor instanceof Ctor || target.type === 'AltStore');\n}\n\nfunction eachObject(f, o) {\n  o.forEach(function (from) {\n    Object.keys(Object(from)).forEach(function (key) {\n      f(key, from[key]);\n    });\n  });\n}\n\nfunction assign(target) {\n  for (var _len = arguments.length, source = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    source[_key - 1] = arguments[_key];\n  }\n\n  eachObject(function (key, value) {\n    return target[key] = value;\n  }, source);\n  return target;\n}","/home/travis/build/npmtest/node-npmtest-alt/node_modules/alt/lib/store/index.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createStoreConfig = createStoreConfig;\nexports.transformStore = transformStore;\nexports.createStoreFromObject = createStoreFromObject;\nexports.createStoreFromClass = createStoreFromClass;\n\nvar _AltUtils = require('../utils/AltUtils');\n\nvar utils = _interopRequireWildcard(_AltUtils);\n\nvar _functions = require('../functions');\n\nvar fn = _interopRequireWildcard(_functions);\n\nvar _AltStore = require('./AltStore');\n\nvar _AltStore2 = _interopRequireDefault(_AltStore);\n\nvar _StoreMixin = require('./StoreMixin');\n\nvar _StoreMixin2 = _interopRequireDefault(_StoreMixin);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction doSetState(store, storeInstance, state) {\n  if (!state) {\n    return;\n  }\n\n  var config = storeInstance.StoreModel.config;\n\n\n  var nextState = fn.isFunction(state) ? state(storeInstance.state) : state;\n\n  storeInstance.state = config.setState.call(store, storeInstance.state, nextState);\n\n  if (!store.alt.dispatcher.isDispatching()) {\n    store.emitChange();\n  }\n}\n\nfunction createPrototype(proto, alt, key, extras) {\n  return fn.assign(proto, _StoreMixin2['default'], {\n    displayName: key,\n    alt: alt,\n    dispatcher: alt.dispatcher,\n    preventDefault: function () {\n      function preventDefault() {\n        this.getInstance().preventDefault = true;\n      }\n\n      return preventDefault;\n    }(),\n\n    boundListeners: [],\n    lifecycleEvents: {},\n    actionListeners: {},\n    publicMethods: {},\n    handlesOwnErrors: false\n  }, extras);\n}\n\nfunction createStoreConfig(globalConfig, StoreModel) {\n  StoreModel.config = fn.assign({\n    getState: function () {\n      function getState(state) {\n        if (Array.isArray(state)) {\n          return state.slice();\n        } else if (fn.isMutableObject(state)) {\n          return fn.assign({}, state);\n        }\n\n        return state;\n      }\n\n      return getState;\n    }(),\n    setState: function () {\n      function setState(currentState, nextState) {\n        if (fn.isMutableObject(nextState)) {\n          return fn.assign(currentState, nextState);\n        }\n        return nextState;\n      }\n\n      return setState;\n    }()\n  }, globalConfig, StoreModel.config);\n}\n\nfunction transformStore(transforms, StoreModel) {\n  return transforms.reduce(function (Store, transform) {\n    return transform(Store);\n  }, StoreModel);\n}\n\nfunction createStoreFromObject(alt, StoreModel, key) {\n  var storeInstance = void 0;\n\n  var StoreProto = createPrototype({}, alt, key, fn.assign({\n    getInstance: function () {\n      function getInstance() {\n        return storeInstance;\n      }\n\n      return getInstance;\n    }(),\n    setState: function () {\n      function setState(nextState) {\n        doSetState(this, storeInstance, nextState);\n      }\n\n      return setState;\n    }()\n  }, StoreModel));\n\n  // bind the store listeners\n  /* istanbul ignore else */\n  if (StoreProto.bindListeners) {\n    _StoreMixin2['default'].bindListeners.call(StoreProto, StoreProto.bindListeners);\n  }\n  /* istanbul ignore else */\n  if (StoreProto.observe) {\n    _StoreMixin2['default'].bindListeners.call(StoreProto, StoreProto.observe(alt));\n  }\n\n  // bind the lifecycle events\n  /* istanbul ignore else */\n  if (StoreProto.lifecycle) {\n    fn.eachObject(function (eventName, event) {\n      _StoreMixin2['default'].on.call(StoreProto, eventName, event);\n    }, [StoreProto.lifecycle]);\n  }\n\n  // create the instance and fn.assign the public methods to the instance\n  storeInstance = fn.assign(new _AltStore2['default'](alt, StoreProto, StoreProto.state !== undefined ? StoreProto.state : {}, StoreModel), StoreProto.publicMethods, {\n    displayName: key,\n    config: StoreModel.config\n  });\n\n  return storeInstance;\n}\n\nfunction createStoreFromClass(alt, StoreModel, key) {\n  var storeInstance = void 0;\n  var config = StoreModel.config;\n\n  // Creating a class here so we don't overload the provided store's\n  // prototype with the mixin behaviour and I'm extending from StoreModel\n  // so we can inherit any extensions from the provided store.\n\n  var Store = function (_StoreModel) {\n    _inherits(Store, _StoreModel);\n\n    function Store() {\n      _classCallCheck(this, Store);\n\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return _possibleConstructorReturn(this, _StoreModel.call.apply(_StoreModel, [this].concat(args)));\n    }\n\n    return Store;\n  }(StoreModel);\n\n  createPrototype(Store.prototype, alt, key, {\n    type: 'AltStore',\n    getInstance: function () {\n      function getInstance() {\n        return storeInstance;\n      }\n\n      return getInstance;\n    }(),\n    setState: function () {\n      function setState(nextState) {\n        doSetState(this, storeInstance, nextState);\n      }\n\n      return setState;\n    }()\n  });\n\n  for (var _len = arguments.length, argsForClass = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    argsForClass[_key - 3] = arguments[_key];\n  }\n\n  var store = new (Function.prototype.bind.apply(Store, [null].concat(argsForClass)))();\n\n  /* istanbul ignore next */\n  if (config.bindListeners) store.bindListeners(config.bindListeners);\n  /* istanbul ignore next */\n  if (config.datasource) store.registerAsync(config.datasource);\n\n  storeInstance = fn.assign(new _AltStore2['default'](alt, store, store.state !== undefined ? store.state : store, StoreModel), utils.getInternalMethods(StoreModel), config.publicMethods, { displayName: key });\n\n  return storeInstance;\n}","/home/travis/build/npmtest/node-npmtest-alt/node_modules/alt/lib/utils/AltUtils.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.getInternalMethods = getInternalMethods;\nexports.getPrototypeChain = getPrototypeChain;\nexports.warn = warn;\nexports.uid = uid;\nexports.formatAsConstant = formatAsConstant;\nexports.dispatchIdentity = dispatchIdentity;\nexports.fsa = fsa;\nexports.dispatch = dispatch;\n\nvar _functions = require('../functions');\n\nvar fn = _interopRequireWildcard(_functions);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\n/*eslint-disable*/\nvar builtIns = Object.getOwnPropertyNames(NoopClass);\nvar builtInProto = Object.getOwnPropertyNames(NoopClass.prototype);\n/*eslint-enable*/\n\nfunction getInternalMethods(Obj, isProto) {\n  var excluded = isProto ? builtInProto : builtIns;\n  var obj = isProto ? Obj.prototype : Obj;\n  return Object.getOwnPropertyNames(obj).reduce(function (value, m) {\n    if (excluded.indexOf(m) !== -1) {\n      return value;\n    }\n\n    value[m] = obj[m];\n    return value;\n  }, {});\n}\n\nfunction getPrototypeChain(Obj) {\n  var methods = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  return Obj === Function.prototype ? methods : getPrototypeChain(Object.getPrototypeOf(Obj), fn.assign(getInternalMethods(Obj, true), methods));\n}\n\nfunction warn(msg) {\n  /* istanbul ignore else */\n  /*eslint-disable*/\n  if (typeof console !== 'undefined') {\n    console.warn(new ReferenceError(msg));\n  }\n  /*eslint-enable*/\n}\n\nfunction uid(container, name) {\n  var count = 0;\n  var key = name;\n  while (Object.hasOwnProperty.call(container, key)) {\n    key = name + String(++count);\n  }\n  return key;\n}\n\nfunction formatAsConstant(name) {\n  return name.replace(/[a-z]([A-Z])/g, function (i) {\n    return String(i[0]) + '_' + String(i[1].toLowerCase());\n  }).toUpperCase();\n}\n\nfunction dispatchIdentity(x) {\n  if (x === undefined) return null;\n\n  for (var _len = arguments.length, a = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    a[_key - 1] = arguments[_key];\n  }\n\n  return a.length ? [x].concat(a) : x;\n}\n\nfunction fsa(id, type, payload, details) {\n  return {\n    type: type,\n    payload: payload,\n    meta: _extends({\n      dispatchId: id\n    }, details),\n\n    id: id,\n    action: type,\n    data: payload,\n    details: details\n  };\n}\n\nfunction dispatch(id, actionObj, payload, alt) {\n  var data = actionObj.dispatch(payload);\n  if (data === undefined) return null;\n\n  var type = actionObj.id;\n  var namespace = type;\n  var name = type;\n  var details = { id: type, namespace: namespace, name: name };\n\n  var dispatchLater = function dispatchLater(x) {\n    return alt.dispatch(type, x, details);\n  };\n\n  if (fn.isFunction(data)) return data(dispatchLater, alt);\n\n  // XXX standardize this\n  return alt.dispatcher.dispatch(fsa(id, type, data, details));\n}\n\n/* istanbul ignore next */\nfunction NoopClass() {}","/home/travis/build/npmtest/node-npmtest-alt/node_modules/alt/lib/store/AltStore.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _functions = require('../functions');\n\nvar fn = _interopRequireWildcard(_functions);\n\nvar _transmitter = require('transmitter');\n\nvar _transmitter2 = _interopRequireDefault(_transmitter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar AltStore = function () {\n  function AltStore(alt, model, state, StoreModel) {\n    var _this = this;\n\n    _classCallCheck(this, AltStore);\n\n    var lifecycleEvents = model.lifecycleEvents;\n    this.transmitter = (0, _transmitter2['default'])();\n    this.lifecycle = function (event, x) {\n      if (lifecycleEvents[event]) lifecycleEvents[event].publish(x);\n    };\n    this.state = state;\n\n    this.alt = alt;\n    this.preventDefault = false;\n    this.displayName = model.displayName;\n    this.boundListeners = model.boundListeners;\n    this.StoreModel = StoreModel;\n    this.reduce = model.reduce || function (x) {\n      return x;\n    };\n    this.subscriptions = [];\n\n    var output = model.output || function (x) {\n      return x;\n    };\n\n    this.emitChange = function () {\n      return _this.transmitter.publish(output(_this.state));\n    };\n\n    var handleDispatch = function handleDispatch(f, payload) {\n      try {\n        return f();\n      } catch (e) {\n        if (model.handlesOwnErrors) {\n          _this.lifecycle('error', {\n            error: e,\n            payload: payload,\n            state: _this.state\n          });\n          return false;\n        }\n\n        throw e;\n      }\n    };\n\n    fn.assign(this, model.publicMethods);\n\n    // Register dispatcher\n    this.dispatchToken = alt.dispatcher.register(function (payload) {\n      _this.preventDefault = false;\n\n      _this.lifecycle('beforeEach', {\n        payload: payload,\n        state: _this.state\n      });\n\n      var actionHandlers = model.actionListeners[payload.action];\n\n      if (actionHandlers || model.otherwise) {\n        var result = void 0;\n\n        if (actionHandlers) {\n          result = handleDispatch(function () {\n            return actionHandlers.filter(Boolean).every(function (handler) {\n              return handler.call(model, payload.data, payload.action) !== false;\n            });\n          }, payload);\n        } else {\n          result = handleDispatch(function () {\n            return model.otherwise(payload.data, payload.action);\n          }, payload);\n        }\n\n        if (result !== false && !_this.preventDefault) _this.emitChange();\n      }\n\n      if (model.reduce) {\n        handleDispatch(function () {\n          var value = model.reduce(_this.state, payload);\n          if (value !== undefined) _this.state = value;\n        }, payload);\n        if (!_this.preventDefault) _this.emitChange();\n      }\n\n      _this.lifecycle('afterEach', {\n        payload: payload,\n        state: _this.state\n      });\n    });\n\n    this.lifecycle('init');\n  }\n\n  AltStore.prototype.listen = function () {\n    function listen(cb) {\n      var _this2 = this;\n\n      if (!fn.isFunction(cb)) throw new TypeError('listen expects a function');\n\n      var _transmitter$subscrib = this.transmitter.subscribe(cb);\n\n      var dispose = _transmitter$subscrib.dispose;\n\n      this.subscriptions.push({ cb: cb, dispose: dispose });\n      return function () {\n        _this2.lifecycle('unlisten');\n        dispose();\n      };\n    }\n\n    return listen;\n  }();\n\n  AltStore.prototype.unlisten = function () {\n    function unlisten(cb) {\n      this.lifecycle('unlisten');\n      this.subscriptions.filter(function (subscription) {\n        return subscription.cb === cb;\n      }).forEach(function (subscription) {\n        return subscription.dispose();\n      });\n    }\n\n    return unlisten;\n  }();\n\n  AltStore.prototype.getState = function () {\n    function getState() {\n      return this.StoreModel.config.getState.call(this, this.state);\n    }\n\n    return getState;\n  }();\n\n  return AltStore;\n}();\n\nexports['default'] = AltStore;\nmodule.exports = exports['default'];","/home/travis/build/npmtest/node-npmtest-alt/node_modules/alt/lib/store/StoreMixin.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _transmitter = require('transmitter');\n\nvar _transmitter2 = _interopRequireDefault(_transmitter);\n\nvar _functions = require('../functions');\n\nvar fn = _interopRequireWildcard(_functions);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar StoreMixin = {\n  waitFor: function () {\n    function waitFor() {\n      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      if (!sources.length) {\n        throw new ReferenceError('Dispatch tokens not provided');\n      }\n\n      var sourcesArray = sources;\n      if (sources.length === 1) {\n        sourcesArray = Array.isArray(sources[0]) ? sources[0] : sources;\n      }\n\n      var tokens = sourcesArray.map(function (source) {\n        return source.dispatchToken || source;\n      });\n\n      this.dispatcher.waitFor(tokens);\n    }\n\n    return waitFor;\n  }(),\n  exportAsync: function () {\n    function exportAsync(asyncMethods) {\n      this.registerAsync(asyncMethods);\n    }\n\n    return exportAsync;\n  }(),\n  registerAsync: function () {\n    function registerAsync(asyncDef) {\n      var _this = this;\n\n      var loadCounter = 0;\n\n      var asyncMethods = fn.isFunction(asyncDef) ? asyncDef(this.alt) : asyncDef;\n\n      var toExport = Object.keys(asyncMethods).reduce(function (publicMethods, methodName) {\n        var desc = asyncMethods[methodName];\n        var spec = fn.isFunction(desc) ? desc(_this) : desc;\n\n        var validHandlers = ['success', 'error', 'loading'];\n        validHandlers.forEach(function (handler) {\n          if (spec[handler] && !spec[handler].id) {\n            throw new Error(String(handler) + ' handler must be an action function');\n          }\n        });\n\n        publicMethods[methodName] = function () {\n          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          var state = _this.getInstance().getState();\n          var value = spec.local && spec.local.apply(spec, [state].concat(args));\n          var shouldFetch = spec.shouldFetch ? spec.shouldFetch.apply(spec, [state].concat(args))\n          /*eslint-disable*/\n          : value == null;\n          /*eslint-enable*/\n          var intercept = spec.interceptResponse || function (x) {\n            return x;\n          };\n\n          var makeActionHandler = function () {\n            function makeActionHandler(action, isError) {\n              return function (x) {\n                var fire = function () {\n                  function fire() {\n                    loadCounter -= 1;\n                    action(intercept(x, action, args));\n                    if (isError) throw x;\n                    return x;\n                  }\n\n                  return fire;\n                }();\n                return _this.alt.trapAsync ? function () {\n                  return fire();\n                } : fire();\n              };\n            }\n\n            return makeActionHandler;\n          }();\n\n          // if we don't have it in cache then fetch it\n          if (shouldFetch) {\n            loadCounter += 1;\n            /* istanbul ignore else */\n            if (spec.loading) spec.loading(intercept(null, spec.loading, args));\n            return spec.remote.apply(spec, [state].concat(args)).then(makeActionHandler(spec.success), makeActionHandler(spec.error, 1));\n          }\n\n          // otherwise emit the change now\n          _this.emitChange();\n          return value;\n        };\n\n        return publicMethods;\n      }, {});\n\n      this.exportPublicMethods(toExport);\n      this.exportPublicMethods({\n        isLoading: function () {\n          function isLoading() {\n            return loadCounter > 0;\n          }\n\n          return isLoading;\n        }()\n      });\n    }\n\n    return registerAsync;\n  }(),\n  exportPublicMethods: function () {\n    function exportPublicMethods(methods) {\n      var _this2 = this;\n\n      fn.eachObject(function (methodName, value) {\n        if (!fn.isFunction(value)) {\n          throw new TypeError('exportPublicMethods expects a function');\n        }\n\n        _this2.publicMethods[methodName] = value;\n      }, [methods]);\n    }\n\n    return exportPublicMethods;\n  }(),\n  emitChange: function () {\n    function emitChange() {\n      this.getInstance().emitChange();\n    }\n\n    return emitChange;\n  }(),\n  on: function () {\n    function on(lifecycleEvent, handler) {\n      if (lifecycleEvent === 'error') this.handlesOwnErrors = true;\n      var bus = this.lifecycleEvents[lifecycleEvent] || (0, _transmitter2['default'])();\n      this.lifecycleEvents[lifecycleEvent] = bus;\n      return bus.subscribe(handler.bind(this));\n    }\n\n    return on;\n  }(),\n  bindAction: function () {\n    function bindAction(symbol, handler) {\n      if (!symbol) {\n        throw new ReferenceError('Invalid action reference passed in');\n      }\n      if (!fn.isFunction(handler)) {\n        throw new TypeError('bindAction expects a function');\n      }\n\n      // You can pass in the constant or the function itself\n      var key = symbol.id ? symbol.id : symbol;\n      this.actionListeners[key] = this.actionListeners[key] || [];\n      this.actionListeners[key].push(handler.bind(this));\n      this.boundListeners.push(key);\n    }\n\n    return bindAction;\n  }(),\n  bindActions: function () {\n    function bindActions(actions) {\n      var _this3 = this;\n\n      fn.eachObject(function (action, symbol) {\n        var matchFirstCharacter = /./;\n        var assumedEventHandler = action.replace(matchFirstCharacter, function (x) {\n          return 'on' + String(x[0].toUpperCase());\n        });\n\n        if (_this3[action] && _this3[assumedEventHandler]) {\n          // If you have both action and onAction\n          throw new ReferenceError('You have multiple action handlers bound to an action: ' + (String(action) + ' and ' + String(assumedEventHandler)));\n        }\n\n        var handler = _this3[action] || _this3[assumedEventHandler];\n        if (handler) {\n          _this3.bindAction(symbol, handler);\n        }\n      }, [actions]);\n    }\n\n    return bindActions;\n  }(),\n  bindListeners: function () {\n    function bindListeners(obj) {\n      var _this4 = this;\n\n      fn.eachObject(function (methodName, symbol) {\n        var listener = _this4[methodName];\n\n        if (!listener) {\n          throw new ReferenceError(String(methodName) + ' defined but does not exist in ' + String(_this4.displayName));\n        }\n\n        if (Array.isArray(symbol)) {\n          symbol.forEach(function (action) {\n            _this4.bindAction(action, listener);\n          });\n        } else {\n          _this4.bindAction(symbol, listener);\n        }\n      }, [obj]);\n    }\n\n    return bindListeners;\n  }()\n};\n\nexports['default'] = StoreMixin;\nmodule.exports = exports['default'];","/home/travis/build/npmtest/node-npmtest-alt/node_modules/alt/lib/actions/index.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports['default'] = makeAction;\n\nvar _functions = require('../functions');\n\nvar fn = _interopRequireWildcard(_functions);\n\nvar _AltUtils = require('../utils/AltUtils');\n\nvar utils = _interopRequireWildcard(_AltUtils);\n\nvar _isPromise = require('is-promise');\n\nvar _isPromise2 = _interopRequireDefault(_isPromise);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction makeAction(alt, namespace, name, implementation, obj) {\n  var id = utils.uid(alt._actionsRegistry, String(namespace) + '.' + String(name));\n  alt._actionsRegistry[id] = 1;\n\n  var data = { id: id, namespace: namespace, name: name };\n\n  var dispatch = function dispatch(payload) {\n    return alt.dispatch(id, payload, data);\n  };\n\n  // the action itself\n  var action = function action() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var invocationResult = implementation.apply(obj, args);\n    var actionResult = invocationResult;\n\n    // async functions that return promises should not be dispatched\n    if (invocationResult !== undefined && !(0, _isPromise2['default'])(invocationResult)) {\n      if (fn.isFunction(invocationResult)) {\n        // inner function result should be returned as an action result\n        actionResult = invocationResult(dispatch, alt);\n      } else {\n        dispatch(invocationResult);\n      }\n    }\n\n    if (invocationResult === undefined) {\n      utils.warn('An action was called but nothing was dispatched');\n    }\n\n    return actionResult;\n  };\n  action.defer = function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return setTimeout(function () {\n      return action.apply(null, args);\n    });\n  };\n  action.id = id;\n  action.data = data;\n\n  // ensure each reference is unique in the namespace\n  var container = alt.actions[namespace];\n  var namespaceId = utils.uid(container, name);\n  container[namespaceId] = action;\n\n  // generate a constant\n  var constant = utils.formatAsConstant(namespaceId);\n  container[constant] = id;\n\n  return action;\n}\nmodule.exports = exports['default'];","/home/travis/build/npmtest/node-npmtest-alt/node_modules/alt/scripts/this-dispatch-to-return.js":"const isDispatch = path => (\n  path.value.type === 'CallExpression' &&\n  path.value.callee.type === 'MemberExpression' &&\n//  path.value.callee.object.type === 'ThisExpression' && // commented out so we support var self = this; self.dispatch();\n  path.value.callee.property.type === 'Identifier' &&\n  path.value.callee.property.name === 'dispatch'\n)\n\nconst isThisActions = path => (\n  path.value.type === 'MemberExpression' &&\n  path.value.object.type === 'MemberExpression' &&\n  path.value.object.property.type === 'Identifier' &&\n  path.value.object.property.name === 'actions'\n)\n\nconst updateDispatchToReturn = j => (p) => {\n  j(p).replaceWith(j.returnStatement(p.value.arguments[0] || null))\n}\n\nconst updateDispatchToCall = j => (p) => {\n  j(p).replaceWith(j.callExpression(j.identifier('dispatch'), p.value.arguments))\n}\n\nconst updateToJustThis = j => (p) => {\n  j(p).replaceWith(j.memberExpression(p.value.object.object, p.value.property))\n}\n\nconst findDispatches = (j, p) => {\n  return j(p).find(j.CallExpression).filter(isDispatch)\n}\n\nconst findThisActionReferences = (j, p) => {\n  return j(p).find(j.MemberExpression).filter(isThisActions)\n}\n\nconst replaceFunction = (j, p) => {\n  j(p).replaceWith(j.functionExpression(\n    null,\n    p.value.params,\n    j.blockStatement([\n      j.returnStatement(\n        j.functionExpression(\n          null,\n          [j.identifier('dispatch')],\n          j.blockStatement(p.value.body.body)\n        )\n      )\n    ])\n  ))\n}\n\nmodule.exports = (file, api) => {\n  const j = api.jscodeshift\n  const root = j(file.source)\n\n  root.find(j.FunctionExpression).forEach((p) => {\n    // ignore constructors\n    if (p.parent.value.type === 'MethodDefinition' && p.parent.value.kind === 'constructor') {\n      return\n    }\n\n    // find all dispatches that are inside the function\n    const dispatches = findDispatches(j, p).size()\n    const withinParent = findDispatches(j, p).filter(x => x.parent.parent.parent.value === p.value).size()\n\n    if (withinParent === 0 && dispatches > 0) {\n      replaceFunction(j, p)\n      findDispatches(j, p).forEach(updateDispatchToCall(j))\n\n    } else if (dispatches === 0) {\n      const hasReturn = j(p).find(j.ReturnStatement).size() > 0\n      if (hasReturn) {\n        console.warn('Could not transform function because it returned', 'at line', p.parent.value.loc.start.line)\n      } else {\n        console.warn('This function does not dispatch?', 'at line', p.parent.value.loc.start.line)\n      }\n\n    // if there are multiple dispatches happening then we'll need to return a\n    // dispatch function and update this.dispatch to a dispatch call\n    } else if (dispatches > 1) {\n      replaceFunction(j, p)\n      findDispatches(j, p).forEach(updateDispatchToCall(j))\n\n    // if there's a single dispatch then it's ok to return to dispatch\n    } else {\n      // if its the only statement within the function\n      if (p.value.body.body.length === 1) {\n        findDispatches(j, p).forEach(updateDispatchToReturn(j))\n      // otherwise lets run the function\n      } else {\n        replaceFunction(j, p)\n        findDispatches(j, p).forEach(updateDispatchToCall(j))\n      }\n    }\n\n    // Also find any mentions to `this.actions`\n    findThisActionReferences(j, p).forEach(updateToJustThis(j))\n  })\n\n  return root.toSource({ quote: 'single' })\n}\n","/home/travis/build/npmtest/node-npmtest-alt/node_modules/alt/src/functions.js":"export const isFunction = x => typeof x === 'function'\n\nexport function isMutableObject(target) {\n  const Ctor = target.constructor\n\n  return (\n    !!target\n    &&\n    Object.prototype.toString.call(target) === '[object Object]'\n    &&\n    isFunction(Ctor)\n    &&\n    !Object.isFrozen(target)\n    &&\n    (Ctor instanceof Ctor || target.type === 'AltStore')\n  )\n}\n\nexport function eachObject(f, o) {\n  o.forEach((from) => {\n    Object.keys(Object(from)).forEach((key) => {\n      f(key, from[key])\n    })\n  })\n}\n\nexport function assign(target, ...source) {\n  eachObject((key, value) => target[key] = value, source)\n  return target\n}\n","/home/travis/build/npmtest/node-npmtest-alt/node_modules/alt/src/index.js":"/* global window */\nimport { Dispatcher } from 'flux'\n\nimport * as StateFunctions from './utils/StateFunctions'\nimport * as fn from './functions'\nimport * as store from './store'\nimport * as utils from './utils/AltUtils'\nimport makeAction from './actions'\n\nclass Alt {\n  constructor(config = {}) {\n    this.config = config\n    this.serialize = config.serialize || JSON.stringify\n    this.deserialize = config.deserialize || JSON.parse\n    this.dispatcher = config.dispatcher || new Dispatcher()\n    this.batchingFunction = config.batchingFunction || (callback => callback())\n    this.actions = { global: {} }\n    this.stores = {}\n    this.storeTransforms = config.storeTransforms || []\n    this.trapAsync = false\n    this._actionsRegistry = {}\n    this._initSnapshot = {}\n    this._lastSnapshot = {}\n  }\n\n  dispatch(action, data, details) {\n    this.batchingFunction(() => {\n      const id = Math.random().toString(18).substr(2, 16)\n\n      // support straight dispatching of FSA-style actions\n      if (action.hasOwnProperty('type') && action.hasOwnProperty('payload')) {\n        const fsaDetails = {\n          id: action.type,\n          namespace: action.type,\n          name: action.type,\n        }\n        return this.dispatcher.dispatch(\n          utils.fsa(id, action.type, action.payload, fsaDetails)\n        )\n      }\n\n      if (action.id && action.dispatch) {\n        return utils.dispatch(id, action, data, this)\n      }\n\n      return this.dispatcher.dispatch(utils.fsa(id, action, data, details))\n    })\n  }\n\n  createUnsavedStore(StoreModel, ...args) {\n    const key = StoreModel.displayName || ''\n    store.createStoreConfig(this.config, StoreModel)\n    const Store = store.transformStore(this.storeTransforms, StoreModel)\n\n    return fn.isFunction(Store)\n      ? store.createStoreFromClass(this, Store, key, ...args)\n      : store.createStoreFromObject(this, Store, key)\n  }\n\n  createStore(StoreModel, iden, ...args) {\n    let key = iden || StoreModel.displayName || StoreModel.name || ''\n    store.createStoreConfig(this.config, StoreModel)\n    const Store = store.transformStore(this.storeTransforms, StoreModel)\n\n    /* istanbul ignore next */\n    if (module.hot) delete this.stores[key]\n\n    if (this.stores[key] || !key) {\n      if (this.stores[key]) {\n        utils.warn(\n          `A store named ${key} already exists, double check your store ` +\n          `names or pass in your own custom identifier for each store`\n        )\n      } else {\n        utils.warn('Store name was not specified')\n      }\n\n      key = utils.uid(this.stores, key)\n    }\n\n    const storeInstance = fn.isFunction(Store)\n      ? store.createStoreFromClass(this, Store, key, ...args)\n      : store.createStoreFromObject(this, Store, key)\n\n    this.stores[key] = storeInstance\n    StateFunctions.saveInitialSnapshot(this, key)\n\n    return storeInstance\n  }\n\n  generateActions(...actionNames) {\n    const actions = { name: 'global' }\n    return this.createActions(actionNames.reduce((obj, action) => {\n      obj[action] = utils.dispatchIdentity\n      return obj\n    }, actions))\n  }\n\n  createAction(name, implementation, obj) {\n    return makeAction(this, 'global', name, implementation, obj)\n  }\n\n  createActions(ActionsClass, exportObj = {}, ...argsForConstructor) {\n    const actions = {}\n    const key = utils.uid(\n      this._actionsRegistry,\n      ActionsClass.displayName || ActionsClass.name || 'Unknown'\n    )\n\n    if (fn.isFunction(ActionsClass)) {\n      fn.assign(actions, utils.getPrototypeChain(ActionsClass))\n      class ActionsGenerator extends ActionsClass {\n        constructor(...args) {\n          super(...args)\n        }\n\n        generateActions(...actionNames) {\n          actionNames.forEach((actionName) => {\n            actions[actionName] = utils.dispatchIdentity\n          })\n        }\n      }\n\n      fn.assign(actions, new ActionsGenerator(...argsForConstructor))\n    } else {\n      fn.assign(actions, ActionsClass)\n    }\n\n    this.actions[key] = this.actions[key] || {}\n\n    fn.eachObject((actionName, action) => {\n      if (!fn.isFunction(action)) {\n        exportObj[actionName] = action\n        return\n      }\n\n      // create the action\n      exportObj[actionName] = makeAction(\n        this,\n        key,\n        actionName,\n        action,\n        exportObj\n      )\n\n      // generate a constant\n      const constant = utils.formatAsConstant(actionName)\n      exportObj[constant] = exportObj[actionName].id\n    }, [actions])\n\n    return exportObj\n  }\n\n  takeSnapshot(...storeNames) {\n    const state = StateFunctions.snapshot(this, storeNames)\n    fn.assign(this._lastSnapshot, state)\n    return this.serialize(state)\n  }\n\n  rollback() {\n    StateFunctions.setAppState(\n      this,\n      this.serialize(this._lastSnapshot),\n      storeInst => {\n        storeInst.lifecycle('rollback')\n        storeInst.emitChange()\n      }\n    )\n  }\n\n  recycle(...storeNames) {\n    const initialSnapshot = storeNames.length\n      ? StateFunctions.filterSnapshots(\n          this,\n          this._initSnapshot,\n          storeNames\n        )\n      : this._initSnapshot\n\n    StateFunctions.setAppState(\n      this,\n      this.serialize(initialSnapshot),\n      (storeInst) => {\n        storeInst.lifecycle('init')\n        storeInst.emitChange()\n      }\n    )\n  }\n\n  flush() {\n    const state = this.serialize(StateFunctions.snapshot(this))\n    this.recycle()\n    return state\n  }\n\n  bootstrap(data) {\n    StateFunctions.setAppState(this, data, (storeInst, state) => {\n      storeInst.lifecycle('bootstrap', state)\n      storeInst.emitChange()\n    })\n  }\n\n  prepare(storeInst, payload) {\n    const data = {}\n    if (!storeInst.displayName) {\n      throw new ReferenceError('Store provided does not have a name')\n    }\n    data[storeInst.displayName] = payload\n    return this.serialize(data)\n  }\n\n  // Instance type methods for injecting alt into your application as context\n\n  addActions(name, ActionsClass, ...args) {\n    this.actions[name] = Array.isArray(ActionsClass)\n      ? this.generateActions.apply(this, ActionsClass)\n      : this.createActions(ActionsClass, ...args)\n  }\n\n  addStore(name, StoreModel, ...args) {\n    this.createStore(StoreModel, name, ...args)\n  }\n\n  getActions(name) {\n    return this.actions[name]\n  }\n\n  getStore(name) {\n    return this.stores[name]\n  }\n\n  static debug(name, alt, win) {\n    const key = 'alt.js.org'\n    let context = win\n    if (!context && typeof window !== 'undefined') {\n      context = window\n    }\n    if (typeof context !== 'undefined') {\n      context[key] = context[key] || []\n      context[key].push({ name, alt })\n    }\n    return alt\n  }\n}\n\nexport default Alt\n","/home/travis/build/npmtest/node-npmtest-alt/node_modules/alt/src/actions/index.js":"import * as fn from '../functions'\nimport * as utils from '../utils/AltUtils'\nimport isPromise from 'is-promise'\n\nexport default function makeAction(alt, namespace, name, implementation, obj) {\n  const id = utils.uid(alt._actionsRegistry, `${namespace}.${name}`)\n  alt._actionsRegistry[id] = 1\n\n  const data = { id, namespace, name }\n\n  const dispatch = (payload) => alt.dispatch(id, payload, data)\n\n  // the action itself\n  const action = (...args) => {\n    const invocationResult = implementation.apply(obj, args)\n    let actionResult = invocationResult\n\n    // async functions that return promises should not be dispatched\n    if (invocationResult !== undefined && !isPromise(invocationResult)) {\n      if (fn.isFunction(invocationResult)) {\n        // inner function result should be returned as an action result\n        actionResult = invocationResult(dispatch, alt)\n      } else {\n        dispatch(invocationResult)\n      }\n    }\n\n    if (invocationResult === undefined) {\n      utils.warn('An action was called but nothing was dispatched')\n    }\n\n    return actionResult\n  }\n  action.defer = (...args) => setTimeout(() => action.apply(null, args))\n  action.id = id\n  action.data = data\n\n  // ensure each reference is unique in the namespace\n  const container = alt.actions[namespace]\n  const namespaceId = utils.uid(container, name)\n  container[namespaceId] = action\n\n  // generate a constant\n  const constant = utils.formatAsConstant(namespaceId)\n  container[constant] = id\n\n  return action\n}\n","/home/travis/build/npmtest/node-npmtest-alt/node_modules/alt/src/store/AltStore.js":"import * as fn from '../functions'\nimport transmitter from 'transmitter'\n\nclass AltStore {\n  constructor(alt, model, state, StoreModel) {\n    const lifecycleEvents = model.lifecycleEvents\n    this.transmitter = transmitter()\n    this.lifecycle = (event, x) => {\n      if (lifecycleEvents[event]) lifecycleEvents[event].publish(x)\n    }\n    this.state = state\n\n    this.alt = alt\n    this.preventDefault = false\n    this.displayName = model.displayName\n    this.boundListeners = model.boundListeners\n    this.StoreModel = StoreModel\n    this.reduce = model.reduce || (x => x)\n    this.subscriptions = []\n\n    const output = model.output || (x => x)\n\n    this.emitChange = () => this.transmitter.publish(output(this.state))\n\n    const handleDispatch = (f, payload) => {\n      try {\n        return f()\n      } catch (e) {\n        if (model.handlesOwnErrors) {\n          this.lifecycle('error', {\n            error: e,\n            payload,\n            state: this.state,\n          })\n          return false\n        }\n\n        throw e\n      }\n    }\n\n    fn.assign(this, model.publicMethods)\n\n    // Register dispatcher\n    this.dispatchToken = alt.dispatcher.register((payload) => {\n      this.preventDefault = false\n\n      this.lifecycle('beforeEach', {\n        payload,\n        state: this.state,\n      })\n\n      const actionHandlers = model.actionListeners[payload.action]\n\n      if (actionHandlers || model.otherwise) {\n        let result\n\n        if (actionHandlers) {\n          result = handleDispatch(() => {\n            return actionHandlers.filter(Boolean).every((handler) => {\n              return handler.call(model, payload.data, payload.action) !== false\n            })\n          }, payload)\n        } else {\n          result = handleDispatch(() => {\n            return model.otherwise(payload.data, payload.action)\n          }, payload)\n        }\n\n        if (result !== false && !this.preventDefault) this.emitChange()\n      }\n\n      if (model.reduce) {\n        handleDispatch(() => {\n          const value = model.reduce(this.state, payload)\n          if (value !== undefined) this.state = value\n        }, payload)\n        if (!this.preventDefault) this.emitChange()\n      }\n\n      this.lifecycle('afterEach', {\n        payload,\n        state: this.state,\n      })\n    })\n\n    this.lifecycle('init')\n  }\n\n  listen(cb) {\n    if (!fn.isFunction(cb)) throw new TypeError('listen expects a function')\n    const { dispose } = this.transmitter.subscribe(cb)\n    this.subscriptions.push({ cb, dispose })\n    return () => {\n      this.lifecycle('unlisten')\n      dispose()\n    }\n  }\n\n  unlisten(cb) {\n    this.lifecycle('unlisten')\n    this.subscriptions\n      .filter(subscription => subscription.cb === cb)\n      .forEach(subscription => subscription.dispose())\n  }\n\n  getState() {\n    return this.StoreModel.config.getState.call(this, this.state)\n  }\n}\n\nexport default AltStore\n","/home/travis/build/npmtest/node-npmtest-alt/node_modules/alt/src/store/index.js":"import * as utils from '../utils/AltUtils'\nimport * as fn from '../functions'\nimport AltStore from './AltStore'\nimport StoreMixin from './StoreMixin'\n\nfunction doSetState(store, storeInstance, state) {\n  if (!state) {\n    return\n  }\n\n  const { config } = storeInstance.StoreModel\n\n  const nextState = fn.isFunction(state)\n    ? state(storeInstance.state)\n    : state\n\n  storeInstance.state = config.setState.call(\n    store,\n    storeInstance.state,\n    nextState\n  )\n\n  if (!store.alt.dispatcher.isDispatching()) {\n    store.emitChange()\n  }\n}\n\nfunction createPrototype(proto, alt, key, extras) {\n  return fn.assign(proto, StoreMixin, {\n    displayName: key,\n    alt: alt,\n    dispatcher: alt.dispatcher,\n    preventDefault() {\n      this.getInstance().preventDefault = true\n    },\n    boundListeners: [],\n    lifecycleEvents: {},\n    actionListeners: {},\n    publicMethods: {},\n    handlesOwnErrors: false,\n  }, extras)\n}\n\nexport function createStoreConfig(globalConfig, StoreModel) {\n  StoreModel.config = fn.assign({\n    getState(state) {\n      if (Array.isArray(state)) {\n        return state.slice()\n      } else if (fn.isMutableObject(state)) {\n        return fn.assign({}, state)\n      }\n\n      return state\n    },\n    setState(currentState, nextState) {\n      if (fn.isMutableObject(nextState)) {\n        return fn.assign(currentState, nextState)\n      }\n      return nextState\n    },\n  }, globalConfig, StoreModel.config)\n}\n\nexport function transformStore(transforms, StoreModel) {\n  return transforms.reduce((Store, transform) => transform(Store), StoreModel)\n}\n\nexport function createStoreFromObject(alt, StoreModel, key) {\n  let storeInstance\n\n  const StoreProto = createPrototype({}, alt, key, fn.assign({\n    getInstance() {\n      return storeInstance\n    },\n    setState(nextState) {\n      doSetState(this, storeInstance, nextState)\n    },\n  }, StoreModel))\n\n  // bind the store listeners\n  /* istanbul ignore else */\n  if (StoreProto.bindListeners) {\n    StoreMixin.bindListeners.call(\n      StoreProto,\n      StoreProto.bindListeners,\n    )\n  }\n  /* istanbul ignore else */\n  if (StoreProto.observe) {\n    StoreMixin.bindListeners.call(\n      StoreProto,\n      StoreProto.observe(alt),\n    )\n  }\n\n  // bind the lifecycle events\n  /* istanbul ignore else */\n  if (StoreProto.lifecycle) {\n    fn.eachObject((eventName, event) => {\n      StoreMixin.on.call(StoreProto, eventName, event)\n    }, [StoreProto.lifecycle])\n  }\n\n  // create the instance and fn.assign the public methods to the instance\n  storeInstance = fn.assign(\n    new AltStore(\n      alt,\n      StoreProto,\n      StoreProto.state !== undefined ? StoreProto.state : {},\n      StoreModel\n    ),\n    StoreProto.publicMethods,\n    {\n      displayName: key,\n      config: StoreModel.config,\n    }\n  )\n\n  return storeInstance\n}\n\nexport function createStoreFromClass(alt, StoreModel, key, ...argsForClass) {\n  let storeInstance\n  const { config } = StoreModel\n\n  // Creating a class here so we don't overload the provided store's\n  // prototype with the mixin behaviour and I'm extending from StoreModel\n  // so we can inherit any extensions from the provided store.\n  class Store extends StoreModel {\n    constructor(...args) {\n      super(...args)\n    }\n  }\n\n  createPrototype(Store.prototype, alt, key, {\n    type: 'AltStore',\n    getInstance() {\n      return storeInstance\n    },\n    setState(nextState) {\n      doSetState(this, storeInstance, nextState)\n    },\n  })\n\n  const store = new Store(...argsForClass)\n\n  /* istanbul ignore next */\n  if (config.bindListeners) store.bindListeners(config.bindListeners)\n    /* istanbul ignore next */\n  if (config.datasource) store.registerAsync(config.datasource)\n\n  storeInstance = fn.assign(\n    new AltStore(\n      alt,\n      store,\n      store.state !== undefined ? store.state : store,\n      StoreModel\n    ),\n    utils.getInternalMethods(StoreModel),\n    config.publicMethods,\n    { displayName: key },\n  )\n\n  return storeInstance\n}\n","/home/travis/build/npmtest/node-npmtest-alt/node_modules/alt/src/store/StoreMixin.js":"import transmitter from 'transmitter'\nimport * as fn from '../functions'\n\nconst StoreMixin = {\n  waitFor(...sources) {\n    if (!sources.length) {\n      throw new ReferenceError('Dispatch tokens not provided')\n    }\n\n    let sourcesArray = sources\n    if (sources.length === 1) {\n      sourcesArray = Array.isArray(sources[0]) ? sources[0] : sources\n    }\n\n    const tokens = sourcesArray.map((source) => {\n      return source.dispatchToken || source\n    })\n\n    this.dispatcher.waitFor(tokens)\n  },\n\n  exportAsync(asyncMethods) {\n    this.registerAsync(asyncMethods)\n  },\n\n  registerAsync(asyncDef) {\n    let loadCounter = 0\n\n    const asyncMethods = fn.isFunction(asyncDef)\n      ? asyncDef(this.alt)\n      : asyncDef\n\n    const toExport = Object.keys(asyncMethods).reduce((publicMethods, methodName) => {\n      const desc = asyncMethods[methodName]\n      const spec = fn.isFunction(desc) ? desc(this) : desc\n\n      const validHandlers = ['success', 'error', 'loading']\n      validHandlers.forEach((handler) => {\n        if (spec[handler] && !spec[handler].id) {\n          throw new Error(`${handler} handler must be an action function`)\n        }\n      })\n\n      publicMethods[methodName] = (...args) => {\n        const state = this.getInstance().getState()\n        const value = spec.local && spec.local(state, ...args)\n        const shouldFetch = spec.shouldFetch\n          ? spec.shouldFetch(state, ...args)\n          /*eslint-disable*/\n          : value == null\n          /*eslint-enable*/\n        const intercept = spec.interceptResponse || (x => x)\n\n        const makeActionHandler = (action, isError) => {\n          return (x) => {\n            const fire = () => {\n              loadCounter -= 1\n              action(intercept(x, action, args))\n              if (isError) throw x\n              return x\n            }\n            return this.alt.trapAsync ? () => fire() : fire()\n          }\n        }\n\n        // if we don't have it in cache then fetch it\n        if (shouldFetch) {\n          loadCounter += 1\n          /* istanbul ignore else */\n          if (spec.loading) spec.loading(intercept(null, spec.loading, args))\n          return spec.remote(state, ...args).then(\n            makeActionHandler(spec.success),\n            makeActionHandler(spec.error, 1)\n          )\n        }\n\n        // otherwise emit the change now\n        this.emitChange()\n        return value\n      }\n\n      return publicMethods\n    }, {})\n\n    this.exportPublicMethods(toExport)\n    this.exportPublicMethods({\n      isLoading: () => loadCounter > 0,\n    })\n  },\n\n  exportPublicMethods(methods) {\n    fn.eachObject((methodName, value) => {\n      if (!fn.isFunction(value)) {\n        throw new TypeError('exportPublicMethods expects a function')\n      }\n\n      this.publicMethods[methodName] = value\n    }, [methods])\n  },\n\n  emitChange() {\n    this.getInstance().emitChange()\n  },\n\n  on(lifecycleEvent, handler) {\n    if (lifecycleEvent === 'error') this.handlesOwnErrors = true\n    const bus = this.lifecycleEvents[lifecycleEvent] || transmitter()\n    this.lifecycleEvents[lifecycleEvent] = bus\n    return bus.subscribe(handler.bind(this))\n  },\n\n  bindAction(symbol, handler) {\n    if (!symbol) {\n      throw new ReferenceError('Invalid action reference passed in')\n    }\n    if (!fn.isFunction(handler)) {\n      throw new TypeError('bindAction expects a function')\n    }\n\n    // You can pass in the constant or the function itself\n    const key = symbol.id ? symbol.id : symbol\n    this.actionListeners[key] = this.actionListeners[key] || []\n    this.actionListeners[key].push(handler.bind(this))\n    this.boundListeners.push(key)\n  },\n\n  bindActions(actions) {\n    fn.eachObject((action, symbol) => {\n      const matchFirstCharacter = /./\n      const assumedEventHandler = action.replace(matchFirstCharacter, (x) => {\n        return `on${x[0].toUpperCase()}`\n      })\n\n      if (this[action] && this[assumedEventHandler]) {\n        // If you have both action and onAction\n        throw new ReferenceError(\n          `You have multiple action handlers bound to an action: ` +\n          `${action} and ${assumedEventHandler}`\n        )\n      }\n\n      const handler = this[action] || this[assumedEventHandler]\n      if (handler) {\n        this.bindAction(symbol, handler)\n      }\n    }, [actions])\n  },\n\n  bindListeners(obj) {\n    fn.eachObject((methodName, symbol) => {\n      const listener = this[methodName]\n\n      if (!listener) {\n        throw new ReferenceError(\n          `${methodName} defined but does not exist in ${this.displayName}`\n        )\n      }\n\n      if (Array.isArray(symbol)) {\n        symbol.forEach((action) => {\n          this.bindAction(action, listener)\n        })\n      } else {\n        this.bindAction(symbol, listener)\n      }\n    }, [obj])\n  },\n}\n\nexport default StoreMixin\n","/home/travis/build/npmtest/node-npmtest-alt/node_modules/alt/src/utils/AltUtils.js":"import * as fn from '../functions'\n\n/*eslint-disable*/\nconst builtIns = Object.getOwnPropertyNames(NoopClass)\nconst builtInProto = Object.getOwnPropertyNames(NoopClass.prototype)\n/*eslint-enable*/\n\nexport function getInternalMethods(Obj, isProto) {\n  const excluded = isProto ? builtInProto : builtIns\n  const obj = isProto ? Obj.prototype : Obj\n  return Object.getOwnPropertyNames(obj).reduce((value, m) => {\n    if (excluded.indexOf(m) !== -1) {\n      return value\n    }\n\n    value[m] = obj[m]\n    return value\n  }, {})\n}\n\nexport function getPrototypeChain(Obj, methods = {}) {\n  return Obj === Function.prototype\n    ? methods\n    : getPrototypeChain(\n        Object.getPrototypeOf(Obj),\n        fn.assign(getInternalMethods(Obj, true), methods)\n      )\n}\n\nexport function warn(msg) {\n  /* istanbul ignore else */\n  /*eslint-disable*/\n  if (typeof console !== 'undefined') {\n    console.warn(new ReferenceError(msg))\n  }\n  /*eslint-enable*/\n}\n\nexport function uid(container, name) {\n  let count = 0\n  let key = name\n  while (Object.hasOwnProperty.call(container, key)) {\n    key = name + String(++count)\n  }\n  return key\n}\n\nexport function formatAsConstant(name) {\n  return name.replace(/[a-z]([A-Z])/g, (i) => {\n    return `${i[0]}_${i[1].toLowerCase()}`\n  }).toUpperCase()\n}\n\nexport function dispatchIdentity(x, ...a) {\n  if (x === undefined) return null\n  return a.length ? [x].concat(a) : x\n}\n\nexport function fsa(id, type, payload, details) {\n  return {\n    type,\n    payload,\n    meta: {\n      dispatchId: id,\n      ...details,\n    },\n\n    id,\n    action: type,\n    data: payload,\n    details,\n  }\n}\n\nexport function dispatch(id, actionObj, payload, alt) {\n  const data = actionObj.dispatch(payload)\n  if (data === undefined) return null\n\n  const type = actionObj.id\n  const namespace = type\n  const name = type\n  const details = { id: type, namespace, name }\n\n  const dispatchLater = x => alt.dispatch(type, x, details)\n\n  if (fn.isFunction(data)) return data(dispatchLater, alt)\n\n    // XXX standardize this\n  return alt.dispatcher.dispatch(fsa(id, type, data, details))\n}\n\n/* istanbul ignore next */\nfunction NoopClass() { }\n","/home/travis/build/npmtest/node-npmtest-alt/node_modules/alt/src/utils/StateFunctions.js":"import * as fn from '../functions'\n\nexport function setAppState(instance, data, onStore) {\n  const obj = instance.deserialize(data)\n  fn.eachObject((key, value) => {\n    const store = instance.stores[key]\n    if (store) {\n      const { config } = store.StoreModel\n      const state = store.state\n      if (config.onDeserialize) obj[key] = config.onDeserialize(value) || value\n      if (fn.isMutableObject(state)) {\n        fn.eachObject(k => delete state[k], [state])\n        fn.assign(state, obj[key])\n      } else {\n        store.state = obj[key]\n      }\n      onStore(store, store.state)\n    }\n  }, [obj])\n}\n\nexport function snapshot(instance, storeNames = []) {\n  const stores = storeNames.length ? storeNames : Object.keys(instance.stores)\n  return stores.reduce((obj, storeHandle) => {\n    const storeName = storeHandle.displayName || storeHandle\n    const store = instance.stores[storeName]\n    const { config } = store.StoreModel\n    store.lifecycle('snapshot')\n    const customSnapshot = config.onSerialize &&\n      config.onSerialize(store.state)\n    obj[storeName] = customSnapshot ? customSnapshot : store.getState()\n    return obj\n  }, {})\n}\n\nexport function saveInitialSnapshot(instance, key) {\n  const state = instance.deserialize(\n    instance.serialize(instance.stores[key].state)\n  )\n  instance._initSnapshot[key] = state\n  instance._lastSnapshot[key] = state\n}\n\nexport function filterSnapshots(instance, state, stores) {\n  return stores.reduce((obj, store) => {\n    const storeName = store.displayName || store\n    if (!state[storeName]) {\n      throw new ReferenceError(`${storeName} is not a valid store`)\n    }\n    obj[storeName] = state[storeName]\n    return obj\n  }, {})\n}\n"}